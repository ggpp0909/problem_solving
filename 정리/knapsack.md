# Knapsack

냅색 알고리즘은 두가지로 나뉨

- Fraction Knapsack (분할가능 배낭문제)
  - 담을 수 있는 물건이 나누어 질 때(설탕, 액체 등 단위무게당 가치가 정해진 물건)
  - 물건의 가격을 무게로 나누어 **무게 대비 가격이 비싼 순서로 물건을 정렬**해서 넣으면 쉽게 해결할 수 있다.
  - 남은 배낭이 감당할 수 있는 무게보다 물건의 무게가 많이 나가면 잘라서 넣으면 된다.  **greedy**로 해결 가능

-  **0-1 Kanpsack** (0-1 배낭문제)

  - 담을 수 있는 물건이 나누어 질 수 없을 때 (담는다 안담는다)
  - 물건, 물건의 무게, 물건의 가격, 배낭의 남은 용량을 모두 고려해야 한다.
  - **dp**로 해결 가능

  

 우리가 지금까지 푼 knapsack은 전부 0-1knapsack이라고 할 수 있음
그냥 그런게 있다~~



#  0-1 Kanpsack (DP)

## 2차원 DP

N: 물건의 개수

K: 배낭의 용량

다음 N개의 줄에 물건의 무게, 가치가 주어졌을 때

```python
N, K = map(int, input().split())

item = [[0,0]]
dp = [[0 for i in range(K + 1)] for j in range(N + 1)]

for _ in range(N):
    item.append(list(map(int, input().split())))

# 냅색
for i in range(1, N + 1):
    for j in range(1, K + 1):
        weight = item[i][0] 
        value = item[i][1]
       
        if j < weight:
            dp[i][j] = dp[i - 1][j] # 가방 용량이 지금 넣으려는 물건 무게보다 작으면 그대로 (아무행동도 못하니까)
        else:
            dp[i][j] = max(dp[i - 1][j], value + dp[i - 1][j - weight])

print(dp[N][K])
```

**점화식 해석**

```
dp[i][j] : 배낭의 무게가 j라고 가정, i번째 물건을 선택했을때 배낭의 담기는 물건의 최대 가치
선택했다는 말은 담았다는 말이 아님, 담을지 안담을지 선택한다는 의미

즉 i번째 물건을 담을 때와 담지 않을때 어떤경우가 더 이득인지 골라야된다.

점화식: 
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + value)

dp[i - 1][j]: 
i번째 물건을 담지 않았을 때의 최대가치 (이미 가방에 담겨있는걸 그대로 들고가)

dp[i - 1][j - weight] + value: 
i번째 물건을 담을 때 갖는 최댓가치 (이미 가방에 담겨있는 거에서 담으려는 물건 무게를 확보한 후 넣는다고 생각)
dp[i - 1][j - weight] 는 지금 넣으려는 물건 무게만큼 확보했을 때의 최대가치가 이미 저장되어있음

정담은 dp[N][K]로 출력:
배낭의 무게가 N이고 K번째 물건까지 모두 고려했을때 최대가치가 들어있으므로
```



## 1차원 DP

굳이 2차원으로 안해도 1차원 dp로 덮어쓰면서 풀이 가능 

많은 메모리 이득을 봄, 시간복잡도 약간 이득 (N * K 전체를 순회하는게 아니므로) 

2차원 DP와 다른점은 **거꾸로 탐색**하면서 풀어야 한다.

```python
N, K = map(int, input().split())
item = [list(map(int, input().split())) for i in range(N)]

dp = [0 for i in range(K + 1)]

for i in range(N):
    weight = item[i][0]
    value = item[i][1]
    for j in range(K, Weight - 1, -1): # 배낭용량을 1씩 줄여나가면서 현재 넣으려는 물건이 담길 수 있는 순간까지만 봄
        dp[j] = max(dp[j], dp[j - weight] + value)
        
pring(dp[k])
```

**점화식 해석**

```
예를들어 배낭용량 20 이라고 가정
dp[j]: 가방의 용량이 j일때 담을수 있는 무건의 최대가치라고 정의

예를들어 초기 dp배열 상태가 아래와 같고 (0이 20개)
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 

처음에 무게가 5, 가치가 7인 물건이 들어온다면? dp배열은 다음과 같아짐
0 0 0 0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 

그다음 무게가 3 ,가치가 2인 물건이 들어온다면?
0 0 0 2 2 7 7 7 9 9 9 9 9 9 9 9 9 9 9 9

이유: 
5번인덱스 전까지는 어차피 물건을 못담고 (가방용량이 5보다 작으니 무게 5를 수용 못함), 
그후에는 저장된 최대가치인 0과 무게 5만큼 확보하고 넣었을때의 최대가치가(dp[j - weight] + value) 맨뒤 인덱스부터 저장됨
dp[20] = dp[15] + 7
dp[19] = dp[16] + 7
...
이를 정방향으로 하면 무게를 확보했을때의 최대가치가 계속 업데이트 되므로 거꾸로 하는것임

두번째 물건이 들어온다면
dp[20]은 7, dp[20 - 3] + 2 는 7 + 2 해서 9, 둘중 최대가치 9
dp[19]은 7, dp[19 - 3] + 2 는 7 + 2 해서 9, 둘중 최대가치 9
...
dp[8]은 7, dp[8 - 3] + 2는 0 + 2 해서 2, 둘중 최대가치 7
dp[7]은 7, dp[7 - 3] + 2는 0 + 2 해서 2, 둘중 최대가치 7
...

dp[5]은 0, dp[5 - 3] + 2는 0 + 2 해서 2, 둘중 최대가치 2
...

그냥 이런식으로 물건 들어올때마다 덮어씌우는 로직
```



#### 참고 Fraction Knapsack (Greedy)

예를들어 설탕, 소금, 간장, 참기름이 있다.

**무게**가 1, **가치**가 10인 설탕은 **단위무게당 가격** 10

**무게**가 7, **가치**가 2인 소금은 **단위무게당 가격** 3.5

**무게**가 2, **가치**가 12인 간장은 **단위무게당 가격** 6

**무게**가 3, **가치**가 11인참기름은 **단위무게당 가격** 3. 66666

배낭에 단위무게단 가격이 높은 설탕, 간장, 참기름, 소금 순서대로 담을 수 있는대로 담아야 최대이득 -> **그리디**

